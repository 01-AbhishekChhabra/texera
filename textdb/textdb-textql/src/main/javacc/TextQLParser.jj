/**
 * JavaCC compilation options
 */
options {
  	/**
  	 * Multiple instances of the parser might be required, thus the parser
  	 * should not be compiled as static (made up by static methods)
  	 */
    STATIC = false;
    /**
	 * Use Unicode Input since Java's implementation of String, Character and
	 * console input uses unicode. Compiling without using UNICODE_INPUT might
	 * lead to unexpected results if you are using the wrong encoding.
	 * Please make sure to provide a source with unicode characters, wrapping
	 * the input in a Java Reader such as FileReader or InputStreamReader
	 * if necessary.
     */
    UNICODE_INPUT = true;
    /**
     * The TextQL language is case-insensitive
     */
    IGNORE_CASE = true;
}

PARSER_BEGIN(TextQLParser)

package edu.uci.ics.textdb.textql.languageparser;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;
import org.apache.commons.lang3.builder.EqualsBuilder;

/**
 * Implementation of a parser for the TextQL query language.
 * Please check README.md for grammar specification
 * 
 * @author Flavio Bayer
 */
public class TextQLParser{
  
	/**
	 * Statement class and subclasses (SelectStatement, CreateViewStatement)
	 * Each Statement class has an id attribute. Statement subclasses have
	 * specific fields related to their function. These classes have no methods.
	 * They are used only as containers to move data.
	 * Statement --+ SelectStatement
	 *             + CreateViewStatement
	 */
    static public abstract class Statement {
        //Identifier of each Statement
		public String id;
		
      	public Statement() {
			this(null);
      	}
      	public Statement(String id) {
			this.id = id;
      	}
      	@Override
      	public boolean equals(Object other) {
			if (other == null) { return false; }
			if (other.getClass() != this.getClass()) { return false; }
			Statement statement = (Statement) other;
			return new EqualsBuilder()
						.append(id, statement.id)
						.isEquals();
      	}
    }
    static public class SelectStatement extends Statement {
        //projectAll is set to true when '*' is used on the fields to be projected, as in "SELECT * ..."
        public Boolean projectAll;
        //projectedFields is the list of fields to be projected if it is specified as in "SELECT a, b, c ...""
        public List<String> projectFields;
        //extractPredicate is the predicate for used for data extraction as keyword match in "KEYWORDMATCH(a,"word")"
        public ExtractPredicate extractPredicate;
        //fromClause is the identifier of a view, as in "SELECT... FROM viewName"
        public String fromClause;
        //limitClause is the maximum number of tuples to be returned, as in "SELECT...FROM... LIMIT 5"
        public Integer limitClause;
        //offsetClause is the number of tuples to be skipped before returning, as in "SELECT...FROM... OFFSET 5"
        public Integer offsetClause;

      	public SelectStatement() {
			this(null, null, null, null, null, null, null);
      	}
      	public SelectStatement(String id, Boolean projectAll,
      						List<String> projectFields, ExtractPredicate extractPredicate,
      						String fromClause, Integer limitClause, Integer offsetClause) {
			super(id);
			this.projectAll = projectAll;
	        this.projectFields = projectFields;
	        this.extractPredicate = extractPredicate;
	        this.fromClause = fromClause;
	        this.limitClause = limitClause;
	        this.offsetClause = offsetClause;
      	}
      	@Override
      	public boolean equals(Object other) {
			if (other == null) { return false; }
			if (other.getClass() != this.getClass()) { return false; }
			SelectStatement selectStatement = (SelectStatement) other;
			return new EqualsBuilder()
						.appendSuper(super.equals(selectStatement))
						.append(projectAll, selectStatement.projectAll)
						.append(projectFields, selectStatement.projectFields)
						.append(extractPredicate, selectStatement.extractPredicate)
						.append(fromClause, selectStatement.fromClause)
						.append(limitClause, selectStatement.limitClause)
						.append(offsetClause, selectStatement.offsetClause)
						.isEquals();
      	}
    }
    static public class CreateViewStatement extends Statement {
        /**
         * Substatement is the statement to which the create view statement creates an alias for
         * e.g. in "CREATE VIEW v AS SELECT *FROM t; the view with id 'v' will have the
         * select statement "SELECT *FROM t" as substatement (in a SlectStatement object)
         */
        public Statement substatement;
      	public CreateViewStatement() {
			this(null, null);
      	}
      	public CreateViewStatement(String id, Statement substatement) {
      	  	super(id);
	        this.substatement = substatement;
      	}
      	@Override
      	public boolean equals(Object other) {
			if (other == null) { return false; }
			if (other.getClass() != this.getClass()) { return false; }
			CreateViewStatement createViweClass = (CreateViewStatement) other;
			return new EqualsBuilder()
						.appendSuper(super.equals(createViweClass))
						.append(substatement, createViweClass.substatement)
						.isEquals();
      	}
    }

	/**
	 * ExtractPredicate class and its subclasses such as KeywordExtractPredicate
	 * Subclasses have specific fields related to its extraction functionalities
	 * These classes have no methods. They are used only as containers
	 * ExtractPredicate --+ KeywordExtractPredicate
	 */
	static public abstract class ExtractPredicate {
      	@Override
      	public boolean equals(Object other) {
			if (other == null) { return false; }
			if (other.getClass() != getClass()) { return false; }
			//since ExtractPredicate has no attributes, there's nothing to compare but the class itself
			return true;
      	}
	}
	static public class KeywordExtractPredicate extends ExtractPredicate {
	    //matchFields is the list of fields which the keyword search should be performed
		public List<String> matchFields;
		//keywords is the keyword(s) used for keyword search
		public String keywords;
		//matchType specifies the type of keyword search to be done
		public String matchType;
		
      	public KeywordExtractPredicate() {
			this(null, null, null);
      	}
      	public KeywordExtractPredicate(List<String> matchFields, String keywords, String matchType) {
	        this.matchFields = matchFields;
	        this.keywords = keywords;
	        this.matchType = matchType;
      	}
      	@Override
      	public boolean equals(Object other) {
			if (other == null) { return false; }
			if (other.getClass() != getClass()) { return false; }
			KeywordExtractPredicate keywordExtractPredicate = (KeywordExtractPredicate) other;
			return new EqualsBuilder()
						.appendSuper(super.equals(keywordExtractPredicate))
						.append(matchFields, keywordExtractPredicate.matchFields)
						.append(keywords, keywordExtractPredicate.keywords)
						.append(matchType, keywordExtractPredicate.matchType)
						.isEquals();
      	}
	}

	/**
	 * Generates a unique deterministic sequence of ids for new statements
     * The id follows the format "_sidX", where X is an incremental hexadecimal
     *  integer without padding starting from 0.
     * e.g. "_lid0", "_lid1", ..., "_lid9", "_lida", ..., "_lidf", "_lid10", ...
	 * @return The generated id
	 */
    private int currentStatementIdSequence = 0;
    private String getNewStatementId(){
        return "_sid" + Integer.toString(currentStatementIdSequence++, 16);
    }
}

PARSER_END(TextQLParser)

/*
 *	Skipped Tokens
 *  The following are tokens that should be ignored/skipped.
 */
SKIP : { " " | "\n" | "\r" | "\t" | "\f" }
/**
 * Basic Tokens - Reserved Words
 */
TOKEN : { < CREATE : "CREATE" > }
TOKEN : { < DIRECTORY : "DIRECTORY" > }
TOKEN : { < VIEW : "VIEW" > }
TOKEN : { < SELECT : "SELECT" > }
TOKEN : { < EXTRACT : "EXTRACT" > }
TOKEN : { < FROM : "FROM" > }
TOKEN : { < AS : "AS" > }
TOKEN : { < LIMIT : "LIMIT" > }
TOKEN : { < OFFSET : "OFFSET" > }
TOKEN : { < JOIN : "JOIN" > }
TOKEN : { < WHERE : "WHERE" > }
TOKEN : { < OUTPUT : "OUTPUT" > }
TOKEN : { < INSERT : "INSERT" > }
TOKEN : { < INTO : "INTO" > }
TOKEN : { < VALUES : "VALUES" > }
TOKEN : { < KEYWORDMATCH : "KEYWORDMATCH" > }
/**
 *	Basic Tokens - Comparison operators
 */
TOKEN : { < ASSIGN: "="> }
TOKEN : { < LT: "<" > }
TOKEN : { < GT: ">" > }
TOKEN : { < EQ: "==" > }
TOKEN : { < LE: "<=" > }
TOKEN : { < GE: ">=" > }
TOKEN : { < NE: "!=" > }
/**
 * Basic Tokens - Other 1-Character tokens
 */
TOKEN : { < LPAREN: "(" > }
TOKEN : { < RPAREN: ")" > }
TOKEN : { < LBRACE: "{" > }
TOKEN : { < RBRACE: "}" > }
TOKEN : { < LBRACKET: "[" > }
TOKEN : { < RBRACKET: "]" > }
TOKEN : { < SEMICOLON: ";" > }
TOKEN : { < COMMA: "," > }
TOKEN : { < DOT: "." > }
TOKEN : { < STAR : "*" > }



/*
 *	Literal Tokens
 */
/**
 *	NUMBER_LITERAL - Matches a number in decimal format
 *  The token matched is composed by an optional ('-') character followed by
 *  (d [ . [d]]) or ('.' d), where d is a digit string, and the bracket content
 *  is optional.
 *  The following are matching examples
 *      0
 *      -0
 *      12
 *      123.
 *      -78.90
 *      -.789
 */
TOKEN : { < NUMBER_LITERAL : ("-")? ((["0"-"9"])+ ("." (["0"-"9"])*)? | "." (["0"-"9"])+) > }
/**
 *	STRING_LITERAL - Matches a quoted string (it may contains escaped quotes)
 *  The token matched is composed by a quote ('"') followed by any character except
 *  for another quote('"'), unless it is escaped('\"') and ended with a quote('"').
 *  The following are matching examples
 *      ""
 *      "abc"
 *      "de f"
 *      "de\" f"
 *      "d\"e\"f"
 *      "de\n f"
 *      "de\\ f"
 */    
TOKEN : { < STRING_LITERAL : "\"" ( "\\" ~[] | ~["\""] )* "\"" > }
/**
 *	REGEX_LITERAL - Matches a regex string delimited by forward slashes
 *                  (it may contains escaped forward slashes)
 *  The token matched is composed by a forward slash ('/') followed by any
 *  character except for another forward slash ('/'), unless it is escaped ('\/')
 *  and ended with a forward slash ('/').
 *  The following are matching examples
 *      //
 *      /abc/
 *      /de f/
 *      /d\/e/
 *      /d\n/
 *      /d\/e\/f/
 *      /"/
 */   
TOKEN : { < REGEX_LITERAL : "/" ( "\\" ~[] | ~["/"] )* "/" > }
/**
 *	IDENTIFIER_LITERAL - Matches an identifier string(e.g. for variable names)
 *  The token matched is composed by an alphabetic character followed by
 *  alphanumeric characters.
 *  The following are matching examples
 *      i
 *      id
 *      id0
 *      i0d
 */ 
TOKEN : { < IDENTIFIER_LITERAL : ["a"-"z"](["a"-"z","0"-"9"])*  > }


/*
 *	Wrappers for literal tokens
 *	Those are simple methods that convert raw Tokens into formated data
 */
/**
 * Consume a NUMBER_LITERAL from the input and convert it to a Double.
 * Examples of valid input: 0, -0, 12, 123., -78.90, -.789
 * @throws NumberFormatException if the conversion to Double fails
 * @return The double representation of the NUMBER_LITERAL
 */
double numberLiteralToDouble():
{
    String numberString;
}
{
    numberString = numberLiteralToString()
    {
    	return Double.parseDouble(numberString);
    }
}
/**
 * Consume a NUMBER_LITERAL from the input and convert it to an Integer.
 * Examples of valid input: 0, -0, 12
 * @throws NumberFormatException if the conversion to Integer fails
 * @return The integer representation of the NUMBER_LITERAL
 */
int numberLiteralToInteger():
{
    String numberString;
}
{
    numberString = numberLiteralToString()
    {
    	return Integer.parseInt(numberString);
    }
}
/**
 * Consume a NUMBER_LITERAL from the input and convert it to a String.
 * Examples of valid input: 0, -0, 12, 123., -78.90, -.789
 * @return The String representation of the NUMBER_LITERAL
 */
String numberLiteralToString():
{
    Token token;
}
{
    token = <NUMBER_LITERAL>
    {
    	return token.image;
    }
}

/**
 * Consume a STRING_LITERAL from input and return convert it to String 
 * Escaped quotes and delimiter quotes are removed
 * Examples of REGEX_LITERAL and the output String(without delimiter simple-quotes):
 *      ""        = > '' (empty)
 *      "abc"     = > 'abc'
 *      "de f"    = > 'de f'
 *      "de\" f"  = > 'de" f'
 *      "d\"e\"f" = > 'd"e"f'
 *      "de\n f"  = > 'de\n f'
 *      "de\\f"   = > 'de\\f'
 * @return The String representation of the STRING_LITERAL
 */
String stringLiteralToString():
{
    Token token;
}
{
    token = <STRING_LITERAL>
    {
    	String string = token.image;
    	String unquotedString = string.substring(1, string.length()-1);
    	String escapedUnquotedString = unquotedString.replace("\\\"", "\"");
    	return escapedUnquotedString;
    }
}
/**
 * Consume a REGEX_LITERAL from input and return convert it to String 
 * Escaped slashes and delimiter slashes are removed
 * Examples of REGEX_LITERAL and the output String(without delimiter quotes):
 *      //         = > "" (empty)
 *      /abc/      = > "abc"
 *      /de f/     = > "de f"
 *      /d\/e/     = > "d/e"
 *      /d\n/      = > "d\n"
 *      /d\/e\/f/  = > "d/e/f"
 *      /"/        = > "\"" (a quote)
 * @return The String representation of the REGEX_LITERAL
 */
String regexLiteralToString():
{
    Token token;
}
{
    token = <REGEX_LITERAL>
    {
    	String regex = token.image;
    	String unslashedRegex = regex.substring(1, regex.length()-1);
    	String escapedUnslashedRegex = unslashedRegex.replace("\\/", "/");
    	return escapedUnslashedRegex;
    }
}
/**
 * Consume an IDENTIFIER_LITERAL from input and convert it to String
 * Examples: i, id, id0, i0d
 * @return The String representation of the IDENTIFIER_LITERAL
 */
String identifierLiteralToString():
{
    Token token;
}
{
    token = <IDENTIFIER_LITERAL>
    {
      return token.image;
    }
}

/*
 *	List of literal tokens separated by commas
 */
/**
 * Consume a list of IDENTIFIER_LITERAL(one or more) from input and convert it to List<String>
 * Example: "i,id,id0,i0d" (without quote) = > { "i", "id", "id0", "i0d" }
 * Grammar: <IdentifierLiteral> ("," <IdentifierLiteral>)* 
 * @return The List<String> representation of the list of IDENTIFIER_LITERAL
 */
List<String> identifierListToListString():
{
    String identifier;
    List<String> identifiers = new ArrayList<String>();
}
{
    identifier = identifierLiteralToString() { identifiers.add(identifier); } 
    (
    	<COMMA> identifier = identifierLiteralToString() { identifiers.add(identifier); }
    )*
    {
    	return identifiers;
    }
}


/*
 *	Statements Declaration
 */
/**
 * Consume the whole input and generates a list containing the declared statement
 * Grammar: (<Statement>)* <EOF>
 * @param statementConsumer The consumer is called after each statement is parsed
 * @return The List<Statement> representation of the whole input
 */
List<Statement> mainStatementList(Consumer<Statement> statementConsumer) : 
{
    List<Statement> statements = new ArrayList();
    Statement newStatement;
}
{
  	//Look for zero or more occurrences of Statement
    (
      	// Parse one statement
        newStatement = statement() { statements.add(newStatement); } 
        {
          	// Call the statement consumer(if we have one) after each statement is parsed
        	if(statementConsumer!=null) { 
        		statementConsumer.accept(newStatement);
        	}
    	}
    )*
    //Consume the End Of File
    <EOF>
    //Return the list of statements generated
    {
    	return statements;
    }
}

/**
 * Consume one statement declaration form the input and generates a Statement
 * object with the parsed data. The kind of statement can either be either
 * SelectStatement or CreateViewStatement
 * Grammar: ( <SelectStatement> | <CreateViewStatement> ) ";"
 * @return The Statement representation of the next statement declaration
 */
Statement statement() : 
{
    Statement newStatement;
}
{
  	// extract one of the types of statement
    (
            newStatement = selectStatement() 
        |
            newStatement = createViewStatement()
    )
    <SEMICOLON>
    // return generated Statement
    {
    	return newStatement;
    }
}

/**
 * Consume a "CREATE VIEW" statement declaration form the input and generates a CreateViewStatement object with the parsed data
 * Examples of valid input:
 * 		CREATE VIEW viewname0 AS <SelectStatement>
 * 		CREATE VIEW viewname0 AS CREATE VIEW viewname1 AS <SelectStatement>
 * Grammar: "CREATE" "VIEW" <Identifier>
	    	"AS" ( <SelectStatement> | <CreateViewStatement> )
 * @return The CreateViewStatement representation of the next statement declaration
 */
CreateViewStatement createViewStatement() : 
{
    CreateViewStatement statementParameters = new CreateViewStatement();
	Statement substatement;
    String viewName;
}
{
  	// extract CREATE VIEW viewName AS
    <CREATE>
    <VIEW>
    viewName = identifierLiteralToString() { statementParameters.id = viewName; }
    <AS>
    // extract substatement: either a SelectStatement or another CreateViewStatement
    (
            substatement = selectStatement() 
        |
            substatement = createViewStatement()
    ){ statementParameters.substatement = substatement; }
    // return generated CreateViewStatement
    {
    	return statementParameters;
    }
}

/**
 * Consume a "SELECT" statement declaration form the input and generates a SelectStatement object with the parsed data
 * Examples of valid input:
 * 		SELECT * FROM t
 * 		SELECT a,b,c FROM t LIMIT 1 OFFSET 8
 * 		EXTRACT KEYWORDMATCH(g0, "key1") FROM k
 * 		SELECT a EXTRACT KEYWORDMATCH(g0, "key1") FROM k
 * 		SELECT * EXTRACT KEYWORDMATCH([h6,h7,k8,k9], "key1", conjunction) FROM k LIMIT 1 OFFSET 8
 * Grammar: (
				   	"SELECT" ( "*" | <identifierListToListString> ) ("EXTRACT" <ExtractPredicate>)?
				|
					"EXTRACT" <ExtractPredicate>
			)
		    "FROM" <Identifier>
		    ("LIMIT" <Number> )?
		    ("OFFSET" <Number> )?
 * @return The SelectStatement representation of the next statement declaration
 */  
SelectStatement selectStatement() : 
{
    SelectStatement statementParameters = new SelectStatement();
	statementParameters.id = getNewStatementId();
    List<String> identifiers;
    String fromClause;
    Integer limitClause;
    Integer offsetClause;
    ExtractPredicate extractPredicate;
}
{
  	//extract SELECT or/and EXTRACT predicate
    (
      		//extract SELECT only or SELECT and EXTRACT 
            (
              	//extract SELECT
	            <SELECT> 
	            ( 
	                    <STAR> { statementParameters.projectAll = true; } // SELECT *
	                | 
	                    identifiers = identifierListToListString() { statementParameters.projectFields = identifiers; } // SELECT a,b,...
	            )
				//extract EXTRACT (optional)
	            (
	              <EXTRACT> extractPredicate = extractPredicate() { statementParameters.extractPredicate = extractPredicate; } // EXTRACT extractPredicate
	            )?
        	)
        |
            //extract EXTRACT only
            <EXTRACT> extractPredicate = extractPredicate() { statementParameters.extractPredicate = extractPredicate; } // EXTRACT only
    )
    //extract FROM field
    <FROM> fromClause = identifierLiteralToString() { statementParameters.fromClause = fromClause; }
    //extract LIMIT field(optional)
    (
      <LIMIT> limitClause = numberLiteralToInteger() { statementParameters.limitClause = limitClause; }
    )?
    //extract OFFSET field(optional)
    (
      <OFFSET> offsetClause = numberLiteralToInteger() { statementParameters.offsetClause = offsetClause; }
    )?
    // return generated SelectStatement
    {
    	return statementParameters;
    }
}


/*
 *	Extract Predicates Declaration
 */
/**
 * Consume one extract predicate form the input and generates a ExtractPredicate object with the parsed data
 * The kind of extract predicate can either be only KeywordExtractPredicate
 * Grammar: ExtractPredicate := (<KeywordExtractPredicate>)
 * @return The ExtractPredicate representation of the next extract predicate
 */
ExtractPredicate extractPredicate() : 
{
    ExtractPredicate extractPredicate;
}
{
  	// extract one of the types of ExtractPedicates
    (
            extractPredicate = extractKeywordMatchPredicate()
    )
    // return generated KeywordExtractPredicate
    {
    	return extractPredicate;
    }
}

/**
 * Consume a keyword extract predicate form the input and generates a KeywordExtractPredicate object with the parsed data
 * Examples of valid input:
 * 		KEYWORDMATCH(g0, "key1")
 * 		KEYWORDMATCH([g6,g7,h8,i9], "key")
 * 		KEYWORDMATCH(g3, "key4", substring)
 * Grammar: "KEYWORDMATCH("
		    	( <Identifier> | "[" <identifierListToListString> "]")
		        "," <String>
		        ("," <Identifier>)?
		    ")"
 * @return The KeywordExtractPredicate representation of the next statement declaration
 */
KeywordExtractPredicate extractKeywordMatchPredicate() : 
{
    KeywordExtractPredicate extractPredicate = new KeywordExtractPredicate();
    List<String> matchFields;
    String matchField;
    String keywords;
    String matchType;
}
{
    <KEYWORDMATCH>
    <LPAREN>
    	//extract the match fields(either a field or list of field)
        (
          		// extract the only field
                matchField = identifierLiteralToString() { matchFields = Arrays.asList(matchField); }
            | 
          		// extract the list of fields between brackets
                <LBRACKET> matchFields = identifierListToListString() <RBRACKET>
        ) { extractPredicate.matchFields = matchFields; }
        // extract the keyword as a string
        <COMMA> keywords = stringLiteralToString() { extractPredicate.keywords = keywords; }
        // extract the match type as an identifier(optional)
        (
        	<COMMA> matchType = identifierLiteralToString() { extractPredicate.matchType = matchType; }
        )?
    <RPAREN>
    // return generated KeywordExtractPredicate
    {
    	return extractPredicate;
    }
}


