options {
    STATIC = false;
    UNICODE_INPUT = true;
}

/*
Compiler Command for JavaCC:
~:/home/virtualbox
root: ~/Desktop/textdb/textdb/textdb-textql/src/main/
JavaCC files: root/javacc
Java Generated Files: root/java/edu/uci/ics/textdb/textql/languageparser

javacc \
-OUTPUT_DIRECTORY:/home/virtualbox/Desktop/textdb/textdb/textdb-textql/src/main/java/edu/uci/ics/textdb/textql/languageparser \
/home/virtualbox/Desktop/textdb/textdb/textdb-textql/src/main/javacc/TextQLParser.jj

*/

PARSER_BEGIN(TextQLParser)

package edu.uci.ics.textdb.textql.languageparser;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;

public class TextQLParser{    
    
    private int _lid = 0;
    private String getNewUniqueId(){
        return "__lid" + Integer.toString(_lid++, 36);
    }
}

PARSER_END(TextQLParser)

/*
 *	Skip Tokens
 */
SKIP : { " " | "\n" | "\r" | "\t" | "\f" }

/*
 *	Basic Tokens
 */
TOKEN : { < CREATE : "CREATE" > }
TOKEN : { < DICTIONARY : "DICTIONARY" > }
TOKEN : { < VIEW : "VIEW" > }
TOKEN : { < SELECT : "SELECT" > }
TOKEN : { < EXTRACT : "EXTRACT" > }
TOKEN : { < FROM : "FROM" > }
TOKEN : { < AS : "AS" > }
TOKEN : { < LIMIT : "LIMIT" > }
TOKEN : { < OFFSET : "OFFSET" > }
TOKEN : { < USING : "USING" > }
TOKEN : { < ON : "ON" > }
TOKEN : { < JOIN : "JOIN" > }
TOKEN : { < WHERE : "WHERE" > }
TOKEN : { < OUTPUT : "OUTPUT" > }
TOKEN : { < INSERT : "INSERT" > }
TOKEN : { < INTO : "INTO" > }
TOKEN : { < VALUES : "VALUES" > }
TOKEN : { < TO : "TO" > }
TOKEN : { < ID : "ID" > }

TOKEN : { <LPAREN: "(" > }
TOKEN : { < RPAREN: ")" > }
TOKEN : { < LBRACE: "{" > }
TOKEN : { < RBRACE: "}" > }
TOKEN : { < LBRACKET: "[" > }
TOKEN : { < RBRACKET: "]" > }
TOKEN : { < SEMICOLON: ";" > }
TOKEN : { < COMMA: "," > }
TOKEN : { < DOT: "." > }
TOKEN : { < STAR : "*" > }

TOKEN : { < ASSIGN: "="> }
TOKEN : { < LT: "<" > }
TOKEN : { < GT: ">" > }
TOKEN : { < EQ: "==" > }
TOKEN : { < LE: "<=" > }
TOKEN : { < GE: ">=" > }
TOKEN : { < NE: "!=" > }

/*
 *	Literal Tokens
 */
TOKEN : { < NUMBER_LITERAL : ("-")? ((["0"-"9"])+ ("." (["0"-"9"])*)? | "." (["0"-"9"])+) > }
TOKEN : { < STRING_LITERAL : "\"" ( "\\" ~[] | ~["\""] )* "\"" > }
TOKEN : { < REGEX_LITERAL : "/" ( "\\" ~[] | ~["/"] )* "/" > }
TOKEN : { < IDENTIFIER : ["a"-"z"] (["a"-"z","0"-"9"])* > }

/*
 *	Wrappers for Literal Tokens
 */
double numberDouble():
{
    String numberString;
}
{
    numberString = numberLiteral() { return Double.parseDouble(numberString); }
}
int numberInteger():
{
    String numberString;
}
{
    numberString = numberLiteral() { return Integer.parseInt(numberString); }
}
String numberLiteral():
{
    Token token;
}
{
    token = <NUMBER_LITERAL> { return token.image; }
}
String regexLiteral():
{
    Token token;
}
{
    token = <REGEX_LITERAL> { return token.image.substring(1, token.image.length()-1).replace("\\/", "/"); }
}
String stringLiteral():
{
    Token token;
}
{
    token = <STRING_LITERAL> { return token.image.substring(1, token.image.length()-1).replace("\\\"", "\""); }
}
String identifier():
{
    Token token;
}
{
    token = <IDENTIFIER> { return token.image; }
}

/*
 *	List of (some) Literal Tokens separated by comma
 */
List<String> identifierList():
{
    String identif;
    List<String> identifiers = new ArrayList<String>();
}
{
    identif=identifier() { identifiers.add(identif); }
    ( <COMMA> identif=identifier() { identifiers.add(identif); } )*
    { return identifiers; }
}


/*
 *	Statements Declaration
 */
List<Map<String, Object>> statementsMain(Consumer<Map<String,Object>> statementConsumer) : 
{
    List<Map<String, Object>> statements = new ArrayList();
    Map<String, Object> newStatement;
}
{
    (
        newStatement = statement() { statements.add(newStatement); }
        { if(statementConsumer!=null)statementConsumer.accept(newStatement); }
    )*
    <EOF>
    { return statements; }
}

Map<String, Object> statement() : 
{
    Map<String, Object> newStatement;
}
{
    (
            newStatement = selectStatement() 
        |
            newStatement = createViewStatement()
        |
            newStatement = emptyStatement()
    )
    <SEMICOLON>
    { return newStatement; }
}

Map<String, Object> selectStatement() : 
{
    HashMap<String, Object> statementParameters = new HashMap<String, Object>() {{
        put("statementType", "select");
        put("statementName", getNewUniqueId());
        put("projectAll", null);
        put("projectFields", null);
        put("extractCommand", null);
        put("from", null);
        put("limit", null);
        put("offset", null);
    }};
    
    List<String> projectFields;
    Map<String,Object> extractCmd;
    String identifier;
    String from;
    Integer limit;
    Integer offset;

}
{
    (
            <SELECT> 
            ( 
                    <STAR> { statementParameters.put("projectAll", true);  } 
                | 
                    { projectFields = new ArrayList<String>(); }
                      identifier=identifier() { projectFields.add(identifier); }
                    ( <COMMA> identifier=identifier() { projectFields.add(identifier); } )*
                    { statementParameters.put("projectFields", projectFields); }
            )
            ( <EXTRACT> extractCmd=extractCommand() { statementParameters.put("extractCommand", extractCmd); } )?
        |
            
            <EXTRACT> extractCmd=extractCommand() { statementParameters.put("extractCommand", extractCmd); } 
    )
    <FROM> from=identifier() { statementParameters.put("from", from); }
    ( <LIMIT> limit=numberInteger() { statementParameters.put("limit", limit); })?
    ( <OFFSET> offset=numberInteger() { statementParameters.put("offset", offset); } )?
    { return statementParameters; }
}

Map<String, Object> createViewStatement() : 
{
    HashMap<String, Object> statementParameters = new HashMap<String, Object>() {{
        put("statementType", "view");
        put("statementName", null);
        put("substatement", null);
    }};
    String viewName;
    Map<String, Object> substatement;
}
{
    <CREATE> 
    <VIEW>
    viewName=identifier() { statementParameters.put("statementName", viewName); }
    <AS> 
    (
            substatement = selectStatement() 
        |
            substatement = createViewStatement()
    ) { statementParameters.put("substatement", substatement); }
    { return statementParameters; }
}

Map<String, Object> emptyStatement() : 
{
    HashMap<String, Object> statementParameters = new HashMap<String, Object>() {{
        put("statementType", "empty");
        put("statementName", getNewUniqueId());
    }};
}
{
    { return statementParameters; }
}



/*
 *	Extract Commands Declaration
 */
Map<String, Object> extractCommand() : 
{
    Map<String, Object> extractParameters = new HashMap<String, Object>() {{
        put("extractType", null);
    }};
}
{
    (
            extractParameters = extractKeywordMatchCommand()
    )
    { return extractParameters; }
}

Map<String, Object> extractKeywordMatchCommand() : 
{
    HashMap<String, Object> extractParameters = new HashMap<String, Object>() {{
        put("extractType", null);
        put("matchFields", null);
        put("keyword", null);
        put("matchType", null);
    }};
    List<String> matchFields;
    String matchField;
    String keyword;
    String matchType;
}
{
    "KEYWORDMATCH" { extractParameters.put("extractType", "keyword"); }
    <LPAREN> 
        ( 
                matchField=identifier() { matchFields = Arrays.asList(matchField); }
            | 
                <LBRACKET> matchFields=identifierList() <RBRACKET>
        ) { extractParameters.put("matchFields", matchFields); }
        <COMMA> keyword=stringLiteral() { extractParameters.put("keyword", keyword); } 
        (<COMMA> matchType=identifier() { extractParameters.put("matchType", matchType); } )?
    <RPAREN>
    { return extractParameters; }
}


